<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Modèle 3D du Tracker Solaire à Trois Mâts</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
    }
    .slider-container {
      margin: 10px 0;
    }
    label {
      display: inline-block;
      width: 180px;
    }
    button {
      margin: 5px;
      padding: 5px 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #45a049;
    }
    .info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div class="controls">
    <h3>Tracker Solaire à Trois Mâts - Corte (42.3°N)</h3>
    <div class="slider-container">
      <label>Heure solaire:</label>
      <input type="range" id="sunPosition" min="5" max="22" value="12" step="0.5">
      <span id="sunPositionValue">12:00</span>
    </div>
    <div class="slider-container">
      <label>Date dans l'année:</label>
      <input type="range" id="yearDate" min="1" max="365" value="172" step="1">
      <span id="yearDateValue">21 juin</span>
    </div>
    <div class="slider-container">
      <label>Inclinaison solaire:</label>
      <input type="range" id="sunElevation" min="20" max="70" value="45" step="1">
      <span id="sunElevationValue">45°</span>
      <span id="dateValue">(21 juin)</span>
    </div>
    <div class="slider-container">
      <label>Longueur câble Sud-Est:</label>
      <input type="range" id="cableSE" min="30" max="120" value="80" step="1">
      <span id="cableSEValue">80</span>
    </div>
    <div class="slider-container">
      <label>Longueur câble Sud-Ouest:</label>
      <input type="range" id="cableSW" min="30" max="120" value="80" step="1">
      <span id="cableSWValue">80</span>
    </div>
    <button id="resetView">Réinitialiser la vue</button>
    <button id="toggleOptimalTrack">Suivre position optimale</button>
    <div id="angleStat"></div>
  </div>
  <div class="info">
    <p>Cliquez et faites glisser pour faire pivoter la vue</p>
    <p>Molette pour zoomer/dézoomer</p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Configuration
    const config = {
      panelWidth: 170,
      panelHeight: 110,
      panelDepth: 5,
      northPoleHeight: 130,
      southPoleHeight: 110,
      poleRadius: 2,
      baseSize: 300,
      baseHeight: 2,
      tracking: true, // Mode tracking activé par défaut
      // Paramètres géographiques pour Corte, Corse (environ 42°N, 9°E)
      latitude: 42.3, // degrés Nord
      longitude: 9.15, // degrés Est
      // Paramètres pour les calculs solaires
      dayOfYear: getCurrentDayOfYear(), // initialiser à la date courante
      timeZone: 2 // UTC+2 (heure d'été en France)
    };
    
    // Fonction pour obtenir le jour actuel de l'année
    function getCurrentDayOfYear() {
      const now = new Date();
      const start = new Date(now.getFullYear(), 0, 0);
      const diff = now - start;
      const oneDay = 1000 * 60 * 60 * 24;
      return Math.floor(diff / oneDay);
    }

    // Initialiser la scène, la caméra et le rendu
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Ciel bleu
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(200, 150, 200);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    // Contrôles de l'orbite
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // Lumière
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    let sunLight = new THREE.DirectionalLight(0xffffcc, 1);
    sunLight.position.set(100, 150, 0);
    sunLight.castShadow = true;
    
    // Améliorer les propriétés de l'ombre
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -300;
    sunLight.shadow.camera.right = 300;
    sunLight.shadow.camera.top = 300;
    sunLight.shadow.camera.bottom = -300;
    sunLight.shadow.bias = -0.0005; // Réduire les artefacts d'ombre
    
    scene.add(sunLight);
    
    // Créer un sol
    const groundGeometry = new THREE.PlaneGeometry(config.baseSize * 2, config.baseSize * 2);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x7cac6e,
      side: THREE.DoubleSide
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Créer une boussole simplifiée dans le coin inférieur droit
    function createCompass() {
      const compassGroup = new THREE.Group();
      compassGroup.position.set(120, -0.5, 120); // Déplacée dans le coin inférieur droit
      
      // Cercle central de la boussole
      const centerGeometry = new THREE.CircleGeometry(15, 32);
      const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.7 });
      const center = new THREE.Mesh(centerGeometry, centerMaterial);
      center.rotation.x = -Math.PI / 2;
      compassGroup.add(center);
      
      // Créer les flèches directionnelles
      function createDirectionArrow(direction, color) {
        const arrowGroup = new THREE.Group();
        
        // Flèche
        const arrowLength = 30;
        const arrowHeadLength = 10;
        const arrowHeadWidth = 8;
        
        // Corps de la flèche
        const bodyGeometry = new THREE.BoxGeometry(3, 1, arrowLength - arrowHeadLength);
        const bodyMaterial = new THREE.MeshBasicMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.z = -(arrowLength - arrowHeadLength) / 2;
        arrowGroup.add(body);
        
        // Tête de la flèche
        const headGeometry = new THREE.ConeGeometry(arrowHeadWidth / 2, arrowHeadLength, 8);
        const headMaterial = new THREE.MeshBasicMaterial({ color: color });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.rotation.x = Math.PI / 2;
        head.position.z = -arrowLength + arrowHeadLength / 2;
        arrowGroup.add(head);
        
        // Indicateur de direction (cube avec la lettre de direction)
        const indicatorGeometry = new THREE.BoxGeometry(8, 2, 8);
        const indicatorMaterial = new THREE.MeshBasicMaterial({ color: color });
        const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
        indicator.position.z = -arrowLength - 10;
        arrowGroup.add(indicator);
        
        // Rotation selon la direction
        if (direction === 'north') {
          arrowGroup.rotation.y = 0;
        } else if (direction === 'south') {
          arrowGroup.rotation.y = Math.PI;
        } else if (direction === 'east') {
          arrowGroup.rotation.y = -Math.PI / 2;
        } else if (direction === 'west') {
          arrowGroup.rotation.y = Math.PI / 2;
        }
        
        return arrowGroup;
      }
      
      // Ajouter les flèches directionnelles avec des couleurs distinctes
      const northArrow = createDirectionArrow('north', 0xff0000); // Rouge pour le Nord
      const southArrow = createDirectionArrow('south', 0x0000ff); // Bleu pour le Sud
      const eastArrow = createDirectionArrow('east', 0x00aa00);  // Vert pour l'Est
      const westArrow = createDirectionArrow('west', 0x00aa00);  // Vert pour l'Ouest
      
      // Ajouter des étiquettes pour les directions
      function createDirectionLabel(x, z, text, color) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const context = canvas.getContext('2d');
        context.fillStyle = '#ffffff';
        context.font = 'Bold 40px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 32, 32);
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide
        });
        
        const labelGeometry = new THREE.PlaneGeometry(10, 10);
        const label = new THREE.Mesh(labelGeometry, material);
        label.position.set(x, 1, z);
        label.rotation.x = -Math.PI / 2;
        
        return label;
      }
      
      // Ajouter les étiquettes
      compassGroup.add(createDirectionLabel(0, -45, 'N', 0xff0000));
      compassGroup.add(createDirectionLabel(0, 45, 'S', 0x0000ff));
      compassGroup.add(createDirectionLabel(45, 0, 'E', 0x00aa00));
      compassGroup.add(createDirectionLabel(-45, 0, 'O', 0x00aa00));
      
      compassGroup.add(northArrow);
      compassGroup.add(southArrow);
      compassGroup.add(eastArrow);
      compassGroup.add(westArrow);
      
      // Ajouter un texte explicatif pour le fonctionnement du tracker
      const infoCanvas = document.createElement('canvas');
      infoCanvas.width = 512;
      infoCanvas.height = 128;
      const infoContext = infoCanvas.getContext('2d');
      
      // Ajouter un fond pour améliorer la lisibilité
      infoContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
      infoContext.fillRect(0, 0, 512, 128);
      infoContext.fillStyle = '#ffffff';
      infoContext.font = 'bold 16px Arial';
      infoContext.textAlign = 'center';
      infoContext.fillText('Tracker solaire à trois mâts: 1 mât fixe au Nord, 2 mâts au Sud avec treuils', 256, 30);
      infoContext.fillText('Les treuils commandés par ordinateur ajustent la longueur des câbles Sud', 256, 55);
      infoContext.fillText('pour orienter le panneau vers le soleil', 256, 80);
      
      const infoTexture = new THREE.CanvasTexture(infoCanvas);
      const infoMaterial = new THREE.MeshBasicMaterial({
        map: infoTexture,
        transparent: true,
        side: THREE.DoubleSide
      });
      
      // Augmenter la taille du panneau d'information pour une meilleure lisibilité
      const infoGeometry = new THREE.PlaneGeometry(150, 40);
      const infoLabel = new THREE.Mesh(infoGeometry, infoMaterial);
      infoLabel.position.set(0, 1, -120);
      infoLabel.rotation.x = -Math.PI / 2;
      compassGroup.add(infoLabel);
      
      return compassGroup;
    }
    
    const compass = createCompass();
    scene.add(compass);
    
    // Base en béton
    const baseGeometry = new THREE.BoxGeometry(config.baseSize, config.baseHeight, config.baseSize);
    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    base.position.y = -config.baseHeight/2;
    base.receiveShadow = true;
    scene.add(base);
    
    // Créer les trois poteaux
    function createPole(x, z, height, color = 0x444444, isSouthPole = false) {
      const poleGroup = new THREE.Group();
      poleGroup.position.set(x, 0, z);
      
      // Créer le poteau principal
      const poleGeometry = new THREE.CylinderGeometry(config.poleRadius, config.poleRadius, height, 16);
      const poleMaterial = new THREE.MeshStandardMaterial({ color });
      const pole = new THREE.Mesh(poleGeometry, poleMaterial);
      pole.position.y = height/2;
      pole.castShadow = true;
      poleGroup.add(pole);
      
      // Ajouter un treuil pour les poteaux sud
      if (isSouthPole) {
        // Boîtier du treuil
        const winchBoxGeometry = new THREE.BoxGeometry(8, 10, 8);
        const winchBoxMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const winchBox = new THREE.Mesh(winchBoxGeometry, winchBoxMaterial);
        winchBox.position.y = height - 15;
        winchBox.position.z = config.poleRadius + 4;
        winchBox.castShadow = true;
        poleGroup.add(winchBox);
        
        // Tambour du treuil
        const winchDrumGeometry = new THREE.CylinderGeometry(3, 3, 6, 16);
        const winchDrumMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
        const winchDrum = new THREE.Mesh(winchDrumGeometry, winchDrumMaterial);
        winchDrum.rotation.x = Math.PI / 2;
        winchDrum.position.y = height - 15;
        winchDrum.position.z = config.poleRadius + 8;
        winchDrum.castShadow = true;
        poleGroup.add(winchDrum);
        
        // Panneau de contrôle (représentant la commande par ordinateur)
        const controlPanelGeometry = new THREE.BoxGeometry(6, 8, 1);
        const controlPanelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const controlPanel = new THREE.Mesh(controlPanelGeometry, controlPanelMaterial);
        controlPanel.position.y = height - 15;
        controlPanel.position.z = config.poleRadius + 12;
        controlPanel.castShadow = true;
        poleGroup.add(controlPanel);
        
        // Petites lumières LED sur le panneau de contrôle
        const ledGeometry = new THREE.CircleGeometry(0.5, 8);
        const ledGreenMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const ledRedMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        
        const ledGreen = new THREE.Mesh(ledGeometry, ledGreenMaterial);
        ledGreen.position.y = height - 13;
        ledGreen.position.z = config.poleRadius + 12.1;
        ledGreen.rotation.y = Math.PI;
        poleGroup.add(ledGreen);
        
        const ledRed = new THREE.Mesh(ledGeometry, ledRedMaterial);
        ledRed.position.y = height - 17;
        ledRed.position.z = config.poleRadius + 12.1;
        ledRed.rotation.y = Math.PI;
        poleGroup.add(ledRed);
      }
      
      scene.add(poleGroup);
      return poleGroup;
    }
    
    // Points d'ancrage des poteaux
    const northPolePos = { x: 0, z: -100 };
    const sePolePos = { x: 80, z: 60 };
    const swPolePos = { x: -80, z: 60 };
    
    // Créer les poteaux
    const northPole = createPole(northPolePos.x, northPolePos.z, config.northPoleHeight, 0x444444, false);
    const sePole = createPole(sePolePos.x, sePolePos.z, config.southPoleHeight, 0x444444, true);
    const swPole = createPole(swPolePos.x, swPolePos.z, config.southPoleHeight, 0x444444, true);
    
    // Sommet des poteaux
    const northPoleTop = new THREE.Vector3(northPolePos.x, config.northPoleHeight, northPolePos.z);
    const sePoleTop = new THREE.Vector3(sePolePos.x, config.southPoleHeight, sePolePos.z);
    const swPoleTop = new THREE.Vector3(swPolePos.x, config.southPoleHeight, swPolePos.z);
    
    // Ajouter des points d'ancrage visibles pour les câbles sur les poteaux sud
    function createCableAnchor(pole, x, y, z) {
      const anchorGeometry = new THREE.SphereGeometry(1.5, 8, 8);
      const anchorMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
      const anchor = new THREE.Mesh(anchorGeometry, anchorMaterial);
      anchor.position.set(x, y, z);
      pole.add(anchor);
      return anchor;
    }
    
    // Créer les points d'ancrage sur les poteaux sud
    createCableAnchor(sePole, 0, config.southPoleHeight, 0);
    createCableAnchor(swPole, 0, config.southPoleHeight, 0);
    
    // Créer le panneau solaire
    const panelGeometry = new THREE.BoxGeometry(config.panelWidth, config.panelDepth, config.panelHeight);
    const panelMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x2244aa,
      metalness: 0.5,
      roughness: 0.1
    });
    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
    panel.castShadow = true;
    panel.receiveShadow = false;
    panel.position.set(0, 50, 0);
    scene.add(panel);
    
    // Créer le vecteur normal au panneau (perpendiculaire)
    const normalVectorLength = 50; // Longueur du vecteur
    const normalGeometry = new THREE.CylinderGeometry(1, 1, normalVectorLength, 8);
    const normalMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Rouge
    const normalVector = new THREE.Mesh(normalGeometry, normalMaterial);
    // Positionner le vecteur pour qu'il sorte perpendiculairement du panneau
    // Pour un panneau horizontal, le vecteur doit pointer vers le haut
    normalVector.position.set(0, normalVectorLength/2, 0);
    // Rotation pour que le cylindre pointe perpendiculairement à la surface du panneau
    // Pour un panneau horizontal (rotation 0), le vecteur doit pointer vers le haut (Y+)
    // Aucune rotation nécessaire car le cylindre est déjà orienté selon l'axe Y
    panel.add(normalVector); // Attacher au panneau pour qu'il suive ses rotations
    
    // Créer un objet représentant le soleil
    const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);
    
    // Créer les câbles
    let lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3 });
    let lineNorth, lineSE, lineSW;
    
    function updateCables() {
      // Supprimer les anciens câbles s'ils existent
      if (lineNorth) scene.remove(lineNorth);
      if (lineSE) scene.remove(lineSE);
      if (lineSW) scene.remove(lineSW);
      
      // Position du centre du panneau
      const panelCenter = panel.position.clone();
      
      // Créer les nouveaux câbles
      // Câble nord
      const northCableGeometry = new THREE.BufferGeometry().setFromPoints([
        northPoleTop,
        new THREE.Vector3(panelCenter.x, panelCenter.y, panelCenter.z - config.panelHeight/2)
      ]);
      lineNorth = new THREE.Line(northCableGeometry, lineMaterial);
      scene.add(lineNorth);
      
      // Câble sud-est
      const seCableGeometry = new THREE.BufferGeometry().setFromPoints([
        sePoleTop,
        new THREE.Vector3(panelCenter.x + config.panelWidth/3, panelCenter.y, panelCenter.z + config.panelHeight/2)
      ]);
      lineSE = new THREE.Line(seCableGeometry, lineMaterial);
      scene.add(lineSE);
      
      // Câble sud-ouest
      const swCableGeometry = new THREE.BufferGeometry().setFromPoints([
        swPoleTop,
        new THREE.Vector3(panelCenter.x - config.panelWidth/3, panelCenter.y, panelCenter.z + config.panelHeight/2)
      ]);
      lineSW = new THREE.Line(swCableGeometry, lineMaterial);
      scene.add(lineSW);
    }
    
    // Calculer la position du panneau en fonction des longueurs de câble
    function updatePanelPosition(cableSELength, cableSWLength) {
      // Position y initiale (hauteur)
      let y = 40;
      
      // Calculer les offsets en x et z qui fonctionnent avec les câbles donnés
      // Formule améliorée pour une meilleure correspondance physique
      
      // Longueur de référence des câbles (position neutre)
      const refLength = 80;
      
      // Calculer la différence par rapport à la position neutre
      const seDiff = cableSELength - refLength;
      const swDiff = cableSWLength - refLength;
      
      // La différence entre les câbles SE et SW détermine l'orientation est-ouest (tiltZ)
      // Facteur ajusté pour une réponse plus réaliste
      let tiltZ = (swDiff - seDiff) * 0.4;
      
      // La somme des différences détermine l'inclinaison nord-sud (tiltX)
      // Facteur ajusté pour une réponse plus réaliste
      let tiltX = (seDiff + swDiff) * 0.5;
      
      // Limiter les angles d'inclinaison à des valeurs réalistes
      // Un tracker solaire réel a des limites mécaniques
      const maxTiltX = 70; // Inclinaison maximale nord-sud
      const maxTiltZ = 60; // Orientation maximale est-ouest
      
      tiltX = Math.max(-maxTiltX, Math.min(maxTiltX, tiltX));
      tiltZ = Math.max(-maxTiltZ, Math.min(maxTiltZ, tiltZ));
      
      // Calculer la hauteur du panneau en fonction des longueurs de câble
      // Modèle physique plus réaliste: la hauteur diminue quand les câbles s'allongent
      // et quand l'inclinaison augmente
      
      // Facteur de base: plus les câbles sont longs, plus le panneau descend
      const cableAvg = (cableSELength + cableSWLength) / 2;
      const heightFactor = (cableAvg - refLength) * 0.2;
      
      // Facteur d'inclinaison: plus le panneau est incliné, plus il descend
      const tiltFactor = (Math.abs(tiltX) + Math.abs(tiltZ) * 0.5) * 0.15;
      
      // Hauteur ajustée
      let adjustedY = y - heightFactor - tiltFactor;
      
      // Limiter la hauteur minimale pour éviter que le panneau ne traverse le sol
      adjustedY = Math.max(15, adjustedY);
      
      // Calculer le décalage horizontal en fonction de l'orientation
      // Un panneau très orienté vers l'est ou l'ouest se déplace légèrement dans cette direction
      const horizontalOffset = tiltZ * 0.3;
      
      panel.position.set(horizontalOffset, adjustedY, 0);
      
      // Orienter le panneau
      panel.rotation.x = tiltX * Math.PI / 180;
      panel.rotation.z = tiltZ * Math.PI / 180;
      
      // Ajuster le vecteur normal pour qu'il soit perpendiculaire au panneau
      // Le vecteur normal doit pointer perpendiculairement à la surface du panneau
      // Comme le panneau est déjà orienté avec les rotations tiltX et tiltZ,
      // le vecteur normal suivra automatiquement ces rotations car il est attaché au panneau
      // Nous n'avons pas besoin de modifier sa rotation ici, car elle est définie lors de la création
      // et le vecteur est attaché au panneau, donc il suit déjà les rotations du panneau
      
      updateCables();
      
      // Mettre à jour les statistiques d'angle
      if (!config.tracking) {
        document.getElementById('angleStat').innerHTML = `
          Inclinaison: ${Math.round(panel.rotation.x * 180 / Math.PI)}°<br>
          Orientation: ${Math.round(panel.rotation.z * 180 / Math.PI)}°
        `;
      }
    }
    
    // Fonctions de calcul astronomique pour la position solaire
    function toRadians(degrees) {
      return degrees * Math.PI / 180;
    }
    
    function toDegrees(radians) {
      return radians * 180 / Math.PI;
    }
    
    // Calcul de la déclinaison solaire en fonction du jour de l'année
    function calculateSolarDeclination(dayOfYear) {
      // Formule de Cooper (1969)
      return 23.45 * Math.sin(toRadians(360 * (284 + dayOfYear) / 365));
    }
    
    // Calcul de l'équation du temps (en minutes)
    function calculateEquationOfTime(dayOfYear) {
      // Angle du jour (en radians)
      const B = toRadians(360 * (dayOfYear - 81) / 365);
      // Formule de Spencer (1971) simplifiée
      return 9.87 * Math.sin(2*B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
    }
    
    // Calcul de l'heure solaire vraie
    function calculateTrueSolarTime(hour, longitude, timeZone, dayOfYear) {
      // Correction pour la longitude et l'équation du temps
      const eot = calculateEquationOfTime(dayOfYear);
      const longitudeCorrection = 4 * (longitude - 15 * timeZone); // 4 minutes par degré
      return hour + (longitudeCorrection + eot) / 60;
    }
    
    // Calcul de l'angle horaire solaire
    function calculateHourAngle(trueSolarTime) {
      // Midi solaire = 0°, chaque heure = 15°
      return 15 * (trueSolarTime - 12);
    }
    
    // Calcul de l'élévation solaire
    function calculateSolarElevation(latitude, declination, hourAngle) {
      const latRad = toRadians(latitude);
      const declRad = toRadians(declination);
      const hourRad = toRadians(hourAngle);
      
      // Formule de l'élévation solaire
      const sinElevation = Math.sin(latRad) * Math.sin(declRad) + 
                          Math.cos(latRad) * Math.cos(declRad) * Math.cos(hourRad);
      
      return toDegrees(Math.asin(sinElevation));
    }
    
    // Calcul de l'azimut solaire
    function calculateSolarAzimuth(latitude, declination, hourAngle, elevation) {
      const latRad = toRadians(latitude);
      const declRad = toRadians(declination);
      const hourRad = toRadians(hourAngle);
      const elevRad = toRadians(elevation);
      
      // Formule de l'azimut solaire
      let sinAzimuth = Math.cos(declRad) * Math.sin(hourRad) / Math.cos(elevRad);
      let cosAzimuth = (Math.sin(declRad) - Math.sin(latRad) * Math.sin(elevRad)) / 
                      (Math.cos(latRad) * Math.cos(elevRad));
      
      let azimuth = toDegrees(Math.atan2(sinAzimuth, cosAzimuth));
      
      // Convertir de la convention astronomique (-180 à +180) à la convention géographique (0 à 360)
      if (hourAngle > 0) {
        azimuth = (azimuth + 360) % 360;
      } else {
        azimuth = (540 - azimuth) % 360;
      }
      
      return azimuth;
    }
    
    // Calcul de la saison en fonction de l'élévation du curseur
    function calculateDayOfYear(elevation) {
      // Convertir l'élévation du curseur (20-70°) en jour de l'année
      // 70° correspond au solstice d'été (jour 172)
      // 20° correspond au solstice d'hiver (jour 355)
      let dayOfYear;
      if (elevation >= 45) {
        // De l'équinoxe de printemps au solstice d'été
        dayOfYear = 80 + Math.round((elevation - 45) * 92 / 25);
      } else {
        // De l'équinoxe d'automne au solstice d'hiver
        dayOfYear = 266 + Math.round((45 - elevation) * 89 / 25);
      }
      return dayOfYear;
    }
    
    // Calcul de l'élévation solaire en fonction du jour de l'année
    function calculateElevationFromDay(dayOfYear) {
      // Convertir le jour de l'année en élévation du curseur (20-70°)
      let elevation;
      if (dayOfYear >= 80 && dayOfYear < 172) {
        // Du printemps à l'été
        elevation = 45 + ((dayOfYear - 80) * 25 / 92);
      } else if (dayOfYear >= 172 && dayOfYear < 266) {
        // De l'été à l'automne
        elevation = 70 - ((dayOfYear - 172) * 25 / 94);
      } else if (dayOfYear >= 266 && dayOfYear < 355) {
        // De l'automne à l'hiver
        elevation = 45 - ((dayOfYear - 266) * 25 / 89);
      } else {
        // De l'hiver au printemps
        if (dayOfYear >= 355) {
          elevation = 20 + ((dayOfYear - 355) * 25 / 91);
        } else { // dayOfYear < 80
          elevation = 20 + ((dayOfYear + 10) * 25 / 91); // +10 pour ajuster (365-355+dayOfYear)
        }
      }
      return Math.round(elevation);
    }
    
    // Convertir le jour de l'année en date
    function dayOfYearToDate(dayOfYear) {
      const year = new Date().getFullYear();
      const date = new Date(year, 0, 1); // 1er janvier de l'année courante
      date.setDate(date.getDate() + dayOfYear - 1); // -1 car le 1er janvier est le jour 1
      
      // Formater la date en français
      const options = { day: 'numeric', month: 'long' };
      return date.toLocaleDateString('fr-FR', options);
    }
    
    // Mettre à jour la position du soleil
    function updateSunPosition(hour, manualElevation) {
      // En mode manuel, utiliser directement les valeurs des curseurs
      if (!config.tracking) {
        // Convertir l'heure en angle pour une trajectoire continue
        // 5h = lever du soleil à l'est, 12h = zénith, 22h = coucher à l'ouest
        const hourNormalized = (hour - 5) / 17; // Normaliser entre 0 et 1
        const angle = hourNormalized * Math.PI; // Convertir en radians (0 à π)
        
        // Utiliser l'élévation du curseur
        const calculatedElevation = manualElevation;
        const elevationRad = calculatedElevation * Math.PI / 180;
        
        // Calculer la position du soleil avec une trajectoire réaliste
        const radius = 250;
        
        // Pour une latitude nord (comme Corte à 42.3°N), le soleil doit suivre une trajectoire
        // qui va de l'est au sud puis à l'ouest, en restant toujours dans la partie sud du ciel
        
        // x est l'axe est-ouest (-x = ouest, +x = est)
        // z est l'axe nord-sud (-z = nord, +z = sud)
        // y est la hauteur
        
        // Calculer la position x (est-ouest)
        const x = Math.sin(angle) * radius * Math.cos(elevationRad);
        
        // Calculer la hauteur y
        const y = Math.sin(elevationRad) * radius;
        
        // Calculer la position z (nord-sud)
        // Utiliser une fonction qui garantit que z reste toujours positif (sud)
        // pour une latitude nord comme Corte
        const z = Math.abs(Math.cos(angle)) * radius * Math.cos(elevationRad);
        
        sun.position.set(x, y, z);
        sunLight.position.set(x, y, z);
        
        // Mettre à jour le jour de l'année en fonction de l'élévation
        config.dayOfYear = calculateDayOfYear(manualElevation);
        
        // Afficher la saison (jour de l'année)
        let seasonText = "";
        if (config.dayOfYear >= 355 || config.dayOfYear < 80) {
          seasonText = "Hiver";
        } else if (config.dayOfYear >= 80 && config.dayOfYear < 172) {
          seasonText = "Printemps";
        } else if (config.dayOfYear >= 172 && config.dayOfYear < 266) {
          seasonText = "Été";
        } else {
          seasonText = "Automne";
        }
        
        // Convertir le jour de l'année en date lisible
        const dateStr = dayOfYearToDate(config.dayOfYear);
        
        // Mettre à jour l'affichage
        document.getElementById('sunElevationValue').textContent = 
          Math.round(calculatedElevation) + '° (' + seasonText + ')';
        document.getElementById('dateValue').textContent = `(${dateStr})`;
        
        return;
      }
      
      // En mode tracking, calculer la position réelle du soleil
      // Mettre à jour le jour de l'année en fonction de l'élévation du curseur
      config.dayOfYear = calculateDayOfYear(manualElevation);
      
      // Calculer la déclinaison solaire pour ce jour
      const declination = calculateSolarDeclination(config.dayOfYear);
      
      // Calculer l'heure solaire vraie
      const trueSolarTime = calculateTrueSolarTime(hour, config.longitude, config.timeZone, config.dayOfYear);
      
      // Calculer l'angle horaire
      const hourAngle = calculateHourAngle(trueSolarTime);
      
      // Calculer l'élévation solaire
      const elevation = calculateSolarElevation(config.latitude, declination, hourAngle);
      
      // Calculer l'azimut solaire
      const azimuth = calculateSolarAzimuth(config.latitude, declination, hourAngle, elevation);
      
      // Convertir l'élévation et l'azimut en coordonnées cartésiennes
      const radius = 250;
      const y = Math.sin(toRadians(elevation)) * radius;
      const horizontalRadius = Math.cos(toRadians(elevation)) * radius;
      const x = Math.sin(toRadians(azimuth)) * horizontalRadius;
      const z = Math.cos(toRadians(azimuth)) * horizontalRadius;
      
      // Mettre à jour la position du soleil
      sun.position.set(x, y, z);
      sunLight.position.set(x, y, z);
      
      // Afficher l'élévation calculée
      document.getElementById('sunElevationValue').textContent = 
        Math.round(elevation) + '° (calculé)';
      
      // Afficher la saison (jour de l'année)
      let seasonText = "";
      if (config.dayOfYear >= 355 || config.dayOfYear < 80) {
        seasonText = "Hiver";
      } else if (config.dayOfYear >= 80 && config.dayOfYear < 172) {
        seasonText = "Printemps";
      } else if (config.dayOfYear >= 172 && config.dayOfYear < 266) {
        seasonText = "Été";
      } else {
        seasonText = "Automne";
      }
      
      // Convertir le jour de l'année en date lisible
      const dateStr = dayOfYearToDate(config.dayOfYear);
      
      // Mettre à jour l'affichage
      document.getElementById('sunElevationValue').textContent += ` (${seasonText})`;
      document.getElementById('dateValue').textContent = `(${dateStr})`;
      
      // Si le tracking est activé, ajuster le panneau pour qu'il soit perpendiculaire aux rayons du soleil
      if (config.tracking) {
        // Calculer l'angle optimal du panneau
        // L'inclinaison (tiltX) doit être l'inverse de l'élévation du soleil par rapport à l'horizon
        const optimalTiltX = 90 - elevation;
        
        // L'orientation (tiltZ) doit suivre l'azimut du soleil
        // Convertir l'azimut (0-360°) en orientation du panneau (-180 à 180°)
        let optimalTiltZ;
        if (azimuth > 180) {
          optimalTiltZ = azimuth - 360;
        } else {
          optimalTiltZ = azimuth;
        }
        // Inverser car le panneau doit faire face au soleil
        optimalTiltZ = -optimalTiltZ;
        
        // Calculer les longueurs de câble nécessaires pour atteindre cette orientation
        // Modèle physique plus réaliste basé sur la géométrie du système à trois mâts
        
        // Facteur de base pour les câbles (longueur au repos)
        const baseCableLength = 80;
        
        // Facteurs d'ajustement pour la conversion angle -> longueur de câble
        // Ces facteurs sont calibrés pour le système spécifique
        const tiltXFactor = 0.35; // Facteur pour l'inclinaison nord-sud
        const tiltZFactor = 0.8;  // Facteur pour l'orientation est-ouest
        
        // Calcul des longueurs de câble
        // Le câble SE s'allonge quand le panneau s'oriente vers l'ouest (tiltZ négatif)
        // et quand l'inclinaison augmente (tiltX positif)
        const seCableLength = baseCableLength - (optimalTiltZ * tiltZFactor) + (optimalTiltX * tiltXFactor);
        
        // Le câble SW s'allonge quand le panneau s'oriente vers l'est (tiltZ positif)
        // et quand l'inclinaison augmente (tiltX positif)
        const swCableLength = baseCableLength + (optimalTiltZ * tiltZFactor) + (optimalTiltX * tiltXFactor);
        
        // Limiter les longueurs de câble aux valeurs min/max des curseurs
        // et ajouter une contrainte physique: la différence entre les câbles ne peut pas être trop grande
        const maxDifference = 60; // Différence maximale entre les longueurs de câble
        
        let limitedSELength = Math.max(30, Math.min(120, seCableLength));
        let limitedSWLength = Math.max(30, Math.min(120, swCableLength));
        
        // Appliquer la contrainte de différence maximale
        if (limitedSELength - limitedSWLength > maxDifference) {
          // Ajuster les deux câbles pour respecter la différence maximale
          const average = (limitedSELength + limitedSWLength) / 2;
          limitedSELength = average + maxDifference / 2;
          limitedSWLength = average - maxDifference / 2;
        } else if (limitedSWLength - limitedSELength > maxDifference) {
          // Ajuster les deux câbles pour respecter la différence maximale
          const average = (limitedSELength + limitedSWLength) / 2;
          limitedSELength = average - maxDifference / 2;
          limitedSWLength = average + maxDifference / 2;
        }
        
        // Mettre à jour les valeurs du curseur
        document.getElementById('cableSE').value = limitedSELength;
        document.getElementById('cableSW').value = limitedSWLength;
        document.getElementById('cableSEValue').textContent = Math.round(limitedSELength);
        document.getElementById('cableSWValue').textContent = Math.round(limitedSWLength);
        
        // Afficher les angles optimaux calculés et les informations solaires
        document.getElementById('angleStat').innerHTML = `
          Inclinaison optimale: ${Math.round(optimalTiltX)}°<br>
          Orientation optimale: ${Math.round(optimalTiltZ)}°<br>
          Élévation solaire: ${Math.round(elevation)}°<br>
          Azimut solaire: ${Math.round(azimuth)}°
        `;
        
        // Mettre à jour la position du panneau
        updatePanelPosition(limitedSELength, limitedSWLength);
      }
    }
    
    // Initialiser les contrôles de l'interface utilisateur
    const cableSESlider = document.getElementById('cableSE');
    const cableSWSlider = document.getElementById('cableSW');
    const sunPositionSlider = document.getElementById('sunPosition');
    const sunElevationSlider = document.getElementById('sunElevation');
    const yearDateSlider = document.getElementById('yearDate');
    const toggleTrackingButton = document.getElementById('toggleOptimalTrack');
    const resetViewButton = document.getElementById('resetView');
    
    cableSESlider.addEventListener('input', function() {
      if (!config.tracking) { // Désactiver en mode tracking
        document.getElementById('cableSEValue').textContent = this.value;
        updatePanelPosition(parseFloat(cableSESlider.value), parseFloat(cableSWSlider.value));
      }
    });
    
    cableSWSlider.addEventListener('input', function() {
      if (!config.tracking) { // Désactiver en mode tracking
        document.getElementById('cableSWValue').textContent = this.value;
        updatePanelPosition(parseFloat(cableSESlider.value), parseFloat(cableSWSlider.value));
      }
    });
    
    // Fonction pour mettre à jour l'état des sliders en fonction du mode tracking
    function updateSliderState() {
      if (config.tracking) {
        cableSESlider.disabled = true;
        cableSWSlider.disabled = true;
      } else {
        cableSESlider.disabled = false;
        cableSWSlider.disabled = false;
      }
    }
    
    sunPositionSlider.addEventListener('input', function() {
      const hour = parseFloat(this.value);
      const hourText = Math.floor(hour) + ':' + (hour % 1 ? '30' : '00');
      document.getElementById('sunPositionValue').textContent = hourText;
      updateSunPosition(hour, parseFloat(sunElevationSlider.value));
    });
    
    sunElevationSlider.addEventListener('input', function() {
      // Mettre à jour l'affichage de l'élévation
      document.getElementById('sunElevationValue').textContent = this.value + '°';
      
      // Mettre à jour le jour de l'année en fonction de l'élévation
      config.dayOfYear = calculateDayOfYear(parseFloat(this.value));
      
      // Mettre à jour l'affichage de la date
      document.getElementById('dateValue').textContent = `(${dayOfYearToDate(config.dayOfYear)})`;
      
      // Synchroniser le slider de date
      yearDateSlider.value = config.dayOfYear;
      document.getElementById('yearDateValue').textContent = dayOfYearToDate(config.dayOfYear);
      
      // Mettre à jour la position du soleil
      updateSunPosition(parseFloat(sunPositionSlider.value), parseFloat(this.value));
    });
    
    yearDateSlider.addEventListener('input', function() {
      // Mettre à jour le jour de l'année
      config.dayOfYear = parseInt(this.value);
      
      // Mettre à jour l'affichage de la date
      const dateStr = dayOfYearToDate(config.dayOfYear);
      document.getElementById('yearDateValue').textContent = dateStr;
      document.getElementById('dateValue').textContent = `(${dateStr})`;
      
      // Calculer et mettre à jour l'élévation correspondante
      const elevation = calculateElevationFromDay(config.dayOfYear);
      sunElevationSlider.value = elevation;
      document.getElementById('sunElevationValue').textContent = elevation + '°';
      
      // Mettre à jour la position du soleil
      updateSunPosition(parseFloat(sunPositionSlider.value), elevation);
    });
    
    toggleTrackingButton.addEventListener('click', function() {
      config.tracking = !config.tracking;
      this.textContent = config.tracking ? 'Désactiver tracking' : 'Suivre position optimale';
      updateSliderState(); // Mettre à jour l'état des sliders
      if (config.tracking) {
        updateSunPosition(parseFloat(sunPositionSlider.value), parseFloat(sunElevationSlider.value));
      }
    });
    
    resetViewButton.addEventListener('click', function() {
      camera.position.set(200, 150, 200);
      controls.target.set(0, 0, 0);
    });
    
    // Redimensionnement de la fenêtre
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialisation
    // Initialiser le slider de date à la date courante
    yearDateSlider.value = config.dayOfYear;
    document.getElementById('yearDateValue').textContent = dayOfYearToDate(config.dayOfYear);
    
    // Calculer l'élévation correspondant à la date courante
    const initialElevation = calculateElevationFromDay(config.dayOfYear);
    sunElevationSlider.value = initialElevation;
    document.getElementById('sunElevationValue').textContent = initialElevation + '°';
    
    // Afficher la date initiale
    document.getElementById('dateValue').textContent = `(${dayOfYearToDate(config.dayOfYear)})`;
    
    // S'assurer que le mode tracking est activé par défaut
    config.tracking = true;
    
    // Mettre à jour l'état des sliders (désactivés en mode tracking)
    updateSliderState();
    
    // Mettre à jour le texte du bouton de tracking
    toggleTrackingButton.textContent = config.tracking ? 'Désactiver tracking' : 'Suivre position optimale';
    
    updatePanelPosition(parseFloat(cableSESlider.value), parseFloat(cableSWSlider.value));
    updateSunPosition(parseFloat(sunPositionSlider.value), initialElevation);
    
    // Boucle d'animation
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
